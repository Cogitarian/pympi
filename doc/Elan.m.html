<!doctype html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>		<html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>		<html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
	<meta charset="utf-8">

      <title>pympi.Elan API documentation</title>
      <meta name="description" content="">

  
  <style type="text/css">
  
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    background: #ddd;
    height: 100%;
  }

  #container {
    width: 840px;
    background-color: #fdfdfd;
    color: #111;
    margin: 0 auto;
    border-left: 1px solid #000;
    border-right: 1px solid #000;
    padding: 10px 25px;
    min-height: 100%;
  }

  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    top: 5px;
    left: 5px;
    font-size: 140%;
  }

  h1 {
    margin: 0 0 10px 0;
  }

  h2 {
    margin: 25px 0 10px 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
  }

  a:hover {
    color: #e08524;
  }

  p {
    line-height: 1.35em;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .ident {
    color: #900;
  }

  code {
    background: #e8e8e8;
  } 

  pre {
    background: #e8e8e8;
    padding: 6px;
    margin: 0 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }

  ul#index {
    padding: 0;
    margin: 0;
  }

    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }

    ul#index li {
      margin-bottom: 18px;
    }

      ul#index ul li {
        margin-bottom: 8px;
      }

    ul#index, ul#index ul {
      list-style-type: none;
    }

    ul#index ul {
      margin: 0 0 10px 20px;
      padding: 0;
    }

  .column_list {
    width: 100%;
    display: inline-block;
    margin-left: 20px;
  }

  .column_list:after {
    visibility: hidden;
    display: block;
    font-size: 0;
    height: 0;
    content: " ";
    clear: both;
  }

    .column_list ul {
      float: left;
      text-align: left;
      width: 32%;
      margin: 0 !important;
    }

  .item {
    margin: 0 0 25px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #e8e8e8;
      padding: 4px;
      margin: 0 0 8px 0;
      font-size: 110%;
      font-weight: bold;
    }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 10px 0;
      padding: 0 8px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 10px 8px 0 8px;
      padding: 0;
    }

    .source_link {
      font-weight: bold;
    }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
    function toggle(id, $link) {
      $node = document.getElementById(id);
      if (!$node)
        return;
      if (!$node.style.display || $node.style.display == 'none') {
        $node.style.display = 'block';
        $link.innerHTML = 'Hide source.';
      } else {
        $node.style.display = 'none';
        $link.innerHTML = 'Show source.';
      }
    }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">

    
  

  


  <h1>Module pympi.Elan</h1>
  
  
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan', this);">Show source.</a></p>
    <div id="source-pympi.Elan" class="source">
      <pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

import EafIO
from time import localtime
import warnings

class Eaf:
	"""Class to work with elan files
	Class variables
	---------------
	annotationDocument      - Dict of all annotationdocument TAG entries.
	fileheader              - String of the header(xml version etc).
	header                  - Dict of the header TAG entries.
	media_descriptors       - List of all linked files: [{attrib}]
	properties              - List of all properties: [(value, {attrib})]
	linked_file_descriptors - List of all secondary linked files: [{attrib}].
	timeslots               - Timeslot data: {TimslotID -> time(ms)}
	tiers                   - Tier data: {TierName -> (alignedAnnotations, referenceAnnotations, attributes, ordinal)}, 
								alignedAnnotations    : [{annotationId -> (beginTs, endTs, value, svg_ref)}]
								referenceAnnotations  : [{annotationId -> (reference, value, previous, svg_ref)}]
	linguistic_types        - Linguistic type data [{id -> attrib}]
	locales                 - List of locale data: [{attrib}]
	constraints             - Constraint data: {stereotype -> description}
	controlled_vocabularies - Controlled vocabulary data: {id -> (description, entries, ext_ref)}
								entry: {description -> (attrib, value)}
	external refs           - External refs [extref]
								extref: [id, type, value]
	lexicon_refs            - Lexicon refs [{attribs}]
	"""

###IO OPERATIONS
	def __init__(self, filePath=None, author='Elan.py', elan_new=True):
		"""Constructor, builds an elan object from file(if given) or an empty one, if elan_new is off then a true minimal file is created if it's on then default entries are added"""
		self.naiveGenAnn = False
		self.naiveGenTS = False
		now = localtime()
		self.annotationDocument = {
				'AUTHOR':author, 
				'DATE':'%.4d-%.2d-%.2dT%.2d:%.2d:%.2d+%.2d:00' % (now[0], now[1], now[2], now[3], now[4], now[5], now[8]), 
				'VERSION':'2.7', 
				'FORMAT':'2.7', 
				'xmlns:xsi':'http://www.w3.org/2001/XMLSchema-instance', 
				'xsi:noNamespaceSchemaLocation':'http://www.mpi.nl/tools/elan/EAFv2.7.xsd'}
		self.controlled_vocabularies, self.constraints, self.tiers, self.linguistic_types, self.header, self.timeslots = {}, {}, {}, {}, {}, {}
		self.external_refs, self.lexicon_refs, self.locales, self.media_descriptors, self.properties, self.linked_file_descriptors = [], [], [], [], [], []
		self.new_time, self.new_ann = 0, 0

		if filePath is None:
			self.addLinguisticType('default-lt', None)
			if elan_new:
				self.constraints = {'Time_Subdivision':'Time subdivision of parent annotation\'s time interval, no time gaps allowed within this interval',
						'Symbolic_Subdivision':'Symbolic subdivision of a parent annotation. Annotations refering to the same parent are ordered',
						'Symbolic_Association':'1-1 association with a parent annotation',
						'Included_In':'Time alignable annotations within the parent annotation\'s time interval, gaps are allowed'}
				self.properties.append(('0', {'NAME': 'lastUsedAnnotation'}))
				self.addTier('default')
		else:
			EafIO.parseEaf(filePath, self)

	def tofile(self, filePath, pretty=True):
		"""Exports the eaf object to a file given by the path, if pretty is false no indentation is used"""
		EafIO.toEaf(filePath, self)

	def toTextGrid(self, filePath, excludedTiers=[]):
		"""Converts the object to praat's TextGrid format and leaves the excludedTiers(optional) behind. returns 0 when succesfull"""
		try:
			from pympi.Praat import TextGrid
		except ImportError:
			warnings.warn('Please install the pympi.Praat module from the pympi module found at https://github.com/dopefishh/pympi')
			return 1
		tgout = TextGrid()
		for tier in [a for a in self.tiers if a not in excludedTiers]:
			currentTier = tgout.addTier(tier)
			for interval in self.getAnnotationDataForTier(tier):
				currentTier.addInterval(interval[0]/1000.0, interval[1]/1000.0, interval[2])
		tgout.tofile(filePath)
		return 0

	def extract(self, start, end):
		"""Extracts a timeframe from the eaf file and returns it"""
		from copy import deepcopy
		eafOut = deepcopy(self)
		for tier in eafOut.tiers.itervalues():
			rems = []
			for ann in tier[0]:
				if eafOut.timeslots[tier[0][ann][1]] > end or eafOut.timeslots[tier[0][ann][0]] < start:
					rems.append(ann)
			for r in rems:
				del tier[0][r]
		return eafOut

###MEDIA OPERATIONS
	def getTimeSeries(self):
		"""Gives a list of all time secondary linked txt files"""
		return [m for m in self.linked_file_descriptors if 'text/plain' in m['MIME_TYPE']]
	
	def getLinkedFiles(self):
		"""Gives a list of all media files"""
		return self.media_descriptors

	def addLinkedFile(self, filePath, relpath=None, mimetype=None, time_origin=None, exfrom=None):
		"""Adds the linked file, if the mimetype is not given it tries to find it(only words for mpg and wav"""
		if mimetype is None:
			mimes = {'wav':'audio/x-wav', 'mpg':'video/mpeg', 'mpeg':'video/mpg'}
			mimetype = mimes[filePath.split('.')[-1]]
		self.media_descriptors.append({'MEDIA_URL':filepath, 'RELATIVE_MEDIA_URL':relpath, 'MIME_TYPE':mimetype, 'TIME_ORIGIN':time_origin, 'EXTRACTED_FROM':exfrom})

###TIER OPERATIONS
	def copyTier(self, eafObj, tierName):
		"""Copies the tier from this object to the given object, if the tier is present it removes it. Returns 0 if succesfull"""
		eafObj.removeTier(tierName)
		try:
			t = self.tiers[tierName][3]
			eafObj.addTier(tierName, tierDict=self.tiers[tierName][3])
			for ann in self.getAnnotationDataForTier(tierName):
				eafObj.insertAnnotation(tierName, ann[0], ann[1], ann[2])
			return 0
		except KeyError:
			warnings.warn('copyTier: Tier non existent!')
			return 1

	def addTier(self, tierId, ling='default-lt', parent=None, locale=None, part=None, ann=None, tierDict=None):
		"""Adds a tier giving a id and type and optional extra data"""
		if tierDict is None:
			self.tiers[tierId] = ({}, {}, {'TIER_ID':tierId, 'LINGUISTIC_TYPE_REF':ling, 'PARENT_REF':parent, 'PARTICIPANT':part, 'DEFAULT_LOCALE':locale, 'ANNOTATOR':ann}, len(self.tiers))
		else:
			self.tiers[tierId] = ({}, {}, tierDict, len(self.tiers))

	def removeTiers(self, tiers):
		"""Removes the given tiers"""
		for a in tiers:
			self.removeTier(a, check=False, clean=False)
		self.cleanTimeSlots()

	def removeTier(self, idTier, check=False, clean=True):
		"""Removes a tier by id, returns 0 if succesfull"""
		try:
			del(self.tiers[idTier])
			if clean: 
				self.cleanTimeSlots()
			return 0
		except KeyError:	
			if check: warnings.warn('removeTier: Tier non existent!\n' + 'looking for: ' + idTier)
			return 1

	def getTierNames(self):
		"""Returns a list of tiernames"""
		return self.tiers.keys()

	def getIndexOfTier(self, idTier):
		"""Returns the index of a given tier, -1 if tier doesn't exist"""
		try:
			return self.tiers[idTier][3]
		except KeyError:
			warnings.warn('getIndexOfTier: Tier non existent!')
			return -1

	def getParameterDictForTier(self, idTier):
		"""Returns a dictionary with all the parameters of the given tier, None if tier doesn't exist"""
		try:
			return self.tiers[idTier][2]
		except KeyError:
			warnings.warn('getParameterDictForTier: Tier non existent!')
			return None

	def childTiersFor(self, idTier):
		"""Returns a list of all the children of the given tier, None if the tier doesn't exist"""
		try:
			return [m for m in self.tiers if 'PARENT_REF' in self.tiers[m][2] and self.tiers[m][2]['PARENT_REF']==idTier]
		except KeyError:
			warnings.warn('childTierFor: Tier non existent!')
			return None

	def getLinguisticTypeForTier(self, idTier):
		"""Returns the locale of the given tier, '' if none and None if tier doesn't exist"""
		try:
			return self.tiers[idTier][2]['LINGUISTIC_TYPE_REF']
		except KeyError:
			warnings.warn('getLinguisticTypeForTier: Tier non existent!')
			return None

	def getLocaleForTier(self, idTier):
		"""Returns the locale of the given tier, '' if none and None if tier doesn't exist"""
		try:
			tier = self.tiers[idTier]
			return '' if 'DEFAULT_LOCALE' not in tier[2] else tier[2]['DEFAULT_LOCALE']
		except KeyError:
			warnings.warn('getLocaleForTier: Tier non existent!')
			return None

	def getParticipantForTier(self, idTier):
		"""Returns the participant for the given tier, '' if none and None if tier doesn't exist"""
		try:
			tier = self.tiers[idTier]
			return '' if 'PARTICIPANT' not in tier[2] else tier[2]['PARTICIPANT']
		except KeyError:
			warnings.warn('getParticipantForTier: Tier non existent')
			return None

###ANNOTATION OPERATIONS
	def getAnnotationDataForTier(self, idTier):
		"""Returns the annotation data for the given tier in the format: (start, end, value)  None if the tier doesn't exist"""
		try:
			a = self.tiers[idTier][0]
			return [(self.timeslots[a[b][0]], self.timeslots[a[b][1]], a[b][2]) for b in a]
		except KeyError:
			warnings.warn('getAnnotationDataForTier: Tier non existent!')
			return None

	def getAnnotationDataAtTime(self, idTier, time):
		"""Returns an annotation at time in the given tier, None if the tier doesn't exist"""
		try:
			anns = self.tiers[idTier][0]
			return sorted([(self.timeslots[m[0]], self.timeslots[m[1]], m[2]) for m in anns.itervalues() if self.timeslots[m[0]]<=time and self.timeslots[m[1]]>=time])
		except KeyError:
			warnings.warn('getAnnotationDataAtTime: Tier non existent!')
			return None

	def getAnnotationDatasBetweenTimes(self, idTier, start, end):
		"""Returns all the annotations overlapping with the given interval in the given tier, None if the tier doesn't exist"""
		try:
			anns = self.tiers[idTier][0]
			return sorted([(self.timeslots[m[0]], self.timeslots[m[1]], m[2]) for m in anns.itervalues() if self.timeslots[m[1]]>=start and self.timeslots[m[0]]<=end])
		except KeyError:
			warnings.warn('getAnnotationDatasBetweenTimes: Tier non existent!')
			return None

	def removeAllAnnotationsFromTier(self, idTier):
		"""Removes all the annotations from the given tier, returns 0 if succesfull"""
		try:
			self.tiers[idTier][0], self.tiers[idTier][1] = {}, {}
			self.cleanTimeSlots()
			return 0
		except KeyError: 
			warnings.warn('removeAllAnnotationsFromTier: Tier non existent!')
			return 1

	def insertAnnotation(self, idTier, start, end, value='', svg_ref=None):
		"""Add an annotation in the given tier, returns 0 if succesfull"""
		try:
			startTs = self.generateTsId(start)
			endTs = self.generateTsId(end)
			self.tiers[idTier][0][self.generateAnnotationId()] = (startTs, endTs, value, svg_ref)
			return 0
		except KeyError:
			warnings.warn('insertAnnotation: Tier non existent')
			return 1
	
	def removeAnnotation(self, time, tier, clean=True):
		"""Removes an annotation at the given time point in the given tier, returns 0 if succesfull"""
		try:
			for b in [a for a in self.tiers[tier][0].iteritems() if a[1][0]>=time and a[1][1]<=time]:
				del(self.tiers[tier][0][b[0]])
				return 0
		except KeyError:
			warnings.warn('removeAnnotation: Tier non existent')
		return 1

	def insertRefAnnotation(self, idTier, ref, value, prev, svg_ref=None):
		"""Adds a reference annotation to the given tier, 0 if succesfull"""
		try:
			self.tiers[idTier][1][self.generateAnnotationId()] = (ref, value, prev, svg_ref)
			return 0
		except KeyError:
			warnings.warn('insertRefAnnotation: Tier non existent')
			return 1

	def getRefAnnotationDataForTier(self, idTier):
		"""Returns all the ref annotation for a given tier in the form: (id->(ref, value, prev, svg_ref), None if the tier doesn't exist"""
		try:
			return self.tiers[idTier][1]
		except KeyError:
			warnings.warn('getRefAnnotationDataForTier: Tier non existent!')
			return None

###CONTROLLED VOCABULARY OPERATIONS
	def addControlledVocabularyToLinguisticType(self, linguisticType, cvId):
		"""Adds a controlled vocabulary to a linguistic type, returns 0 if succesfull"""
		try:
			self.linguistic_types[linguisticType]['CONTROLLED_VOCABULARY_REF'] = cvId
			return 0
		except KeyError:
			warnings.warn('addControlledVocabularyToLinguisticType: Linguistic type non existent!')
			return 1

	def removeControlledVocabulary(self, cv):
		"""Removes a controlled vocabulary, returns 0 if succesfull"""
		try:
			del(self.controlled_vocabularies[cv])
			return 0
		except KeyError:
			warnings.warn('removeControlledVocabulary: Controlled vocabulary non existent!')
			return 1

###HELPER FUNCTIONS
	def generateAnnotationId(self):
		"""Helper function to generate the newest annotation id"""
		if self.naiveGenAnn:
			new = self.lastAnn+1
			self.lastAnn = new
		else:
			new = 1
			anns = {int(ann[1:]) for tier in self.tiers.itervalues() for ann in tier[0]}
			if len(anns) > 0:
				newann = set(xrange(1, max(anns))).difference(anns)
				if len(newann) == 0:
					new = max(anns)+1
					self.naiveGenAnn = True
					self.lastAnn = new
				else:
					new = sorted(newann)[0]
		return 'a%d' % new

	def generateTsId(self, time=None):
		"""Helper function te generate the newest timeslot id"""
		if self.naiveGenTS:
			new = self.lastTS+1
			self.lastTS = new
		else:
			new = 1
			tss = {int(x[2:]) for x in self.timeslots}
			if len(tss) > 0:
				newts = set(xrange(1, max(tss))).difference(tss)
				if len(newts) == 0:
					new = max(tss)+1
					self.naiveGenTS = True
					self.lastTS = new
				else:
					new = sorted(newts)[0]
		ts = 'ts%d' % new
		self.timeslots[ts] = time
		return ts

	def cleanTimeSlots(self):
		"""Removes all the unused timeslots"""
		tsInTier = set(sum([a[0:2] for tier in self.tiers.itervalues() for a in tier[0].itervalues()], ()))
		tsAvail = set(self.timeslots)
		for a in tsInTier.symmetric_difference(tsAvail):
			del(self.timeslots[a])
		self.naiveGenTS = False
		self.naiveGenAnn = False

###ADVANCED FUNCTIONS
	def generateAnnotationConcat(self, tiers, start, end):
		"""Generates a general value combining all the unique values within the tiers given"""
		return '_'.join(set(d[2] for t in tiers if t in self.tiers for d in self.getAnnotationDatasBetweenTimes(t, start, end)))

	def mergeTiers(self, tiers, tiernew=None, gaptresh=1):
		"""Merges the given tiers together in the new tier, returns 0 if succesfull"""
		if len([t for t in tiers if t not in self.tiers]) > 0:
			warnings.warn('mergeTiers: One or more tiers non existent!')
			return 1        
		if tiernew is None: 
			tiernew = '%s_Merged' % '_'.join(tiers)
		self.removeTier(tiernew)
		self.addTier(tiernew)
		try:
			timepts = sorted(set.union(\
			*[set(j for j in xrange(d[0], d[1])) for d in\
			[ann for tier in tiers for ann in self.getAnnotationDataForTier(tier)]]))
		except TypeError:
			warnings.warn('mergeTiers: No annotations found!')
			return 1
		if len(timepts) > 1:
			start = timepts[0]
			for i in xrange(1, len(timepts)):
				if timepts[i]-timepts[i-1] > gaptresh:
					self.insertAnnotation(tiernew, start, timepts[i-1], self.generateAnnotationConcat(tiers, start, timepts[i-1]))
					start = timepts[i]
			self.insertAnnotation(tiernew, start, timepts[i-1], self.generateAnnotationConcat(tiers, start, timepts[i-1]))
		return 0

	def shiftAnnotations(self, time):
		"""Returns a copy of the object with the timeshift of the desired ms (negative for right shift, positive for left shift)"""
		e = self.extract(-1*time, self.getFullTimeInterval()[1]) if time < 0 else self.extract(0, self.getFullTimeInterval()[1]-time)
		for tier in e.tiers.itervalues():
			for ann in tier[0].itervalues():
				e.timeslots[ann[0]],e.timeslots[ann[1]] = e.timeslots[ann[0]]+offset, e.timeslots[ann[1]]+offset
		e.cleanTimeSlots()
		return e

	def filterAnnotations(self, tier, tierName=None, filtin=None, filtex=None):
		"""Filters the tier, retuns 0 when succesfull"""
		if tier not in self.tiers:
			warnings.warn('filterAnnotations: Tier non existent!' + tier)
			return 1
		if tierName is None:
			tierName = '%s_filter' % tier1
		self.removeTier(tierName)
		self.addTier(tierName)
		for a in [b for b in self.getAnnotationDataForTier(tier) if (filtex is None or b[2] not in filtex) and (filtin is None or b[2] in filtin)]:
			self.insertAnnotation(tierName, a[0], a[1], a[2])
		return 0

	def glueAnnotationsInTier(self, tier, tierName=None, treshhold=85, filtin=None, filtex=None):
		"""Glues all the continues annotations together, returns 0 if succesfull"""
		if tier not in self.tiers:
			warnings.warn('glueAnnotationsInTier: Tier non existent!')
			return 1
		if tierName is None: 
			tierName = '%s_glued' % tier
		self.removeTier(tierName)
		self.addTier(tierName)
		tierData = sorted(self.getAnnotationDataForTier(tier), key=lambda a: a[0])
		tierData = [t for t in tierData if (filtin is None or t[2] in filtin) and (filtex is None or t[2] not in filtex)]
		currentAnn = None
		for i in xrange(0, len(tierData)):
			if currentAnn is None:
				currentAnn = (tierData[i][0], tierData[i][1], tierData[i][2])
			elif tierData[i][0]-currentAnn[1]<treshhold:
				currentAnn = (currentAnn[0], tierData[i][1], '%s_%s' % (currentAnn[2], tierData[i][2]))
			else:
				self.insertAnnotation(tierName, currentAnn[0], currentAnn[1], currentAnn[2])
				currentAnn = tierData[i]
		if currentAnn is not None:
			self.insertAnnotation(tierName, currentAnn[0], tierData[len(tierData)-1][1], currentAnn[2])
		return 0

	def getFullTimeInterval(self):
		"""Returns a tuple (start, end) of the full time frame"""
		return (min(self.timeslots.itervalues()), max(self.timeslots.itervalues()))

	def createGapsAndOverlapsTier(self, tier1, tier2, tierName=None, maxlen=-1, tierType=None):
		"""Creates a tier out of the gaps and overlap between two tiers, returns the fto data, returns None if one of the tiers doesn't exist"""
		if tier1 not in self.tiers or tier2 not in self.tiers:
			warnings.warn('createGapsAndOverlapsTier: One or more tiers non existent!')
			return None
		if tierName is None:
			tierName = '%s_%s_ftos' % (tier1, tier2)
		self.removeTier(tierName)
		self.addTier(tierName)
		ftos = self.getGapsAndOverlapsDuration(tier1, tier2, maxlen)
		for fto in ftos:
			self.insertAnnotation(tierName, fto[1], fto[2], fto[0])
		return ftos

	def getGapsAndOverlapsDuration(self, tier1, tier2, maxlen=-1, progressbar=False):
		"""Gives the gaps and overlaps between tiers in the format: (type, start, end), None if one of the tiers don't exist."""
		if tier1 not in self.tiers or tier2 not in self.tiers: 
			warnings.warn('getGapsAndOverlapsDuration: One or more tiers non existent!')
			return None
		spkr1anns = sorted((self.timeslots[a[0]], self.timeslots[a[1]]) for a in self.tiers[tier1][0].values())
		spkr2anns = sorted((self.timeslots[a[0]], self.timeslots[a[1]]) for a in self.tiers[tier2][0].values())
		line1 = []
		isin = lambda x, lst: False if len([i for i in lst if i[0]<=x and i[1]>=x])==0 else True
		try:
			minmax = (min(spkr1anns[0][0], spkr2anns[0][0]), max(spkr1anns[-1][1], spkr2anns[-1][1]))
		except IndexError:
			warnings.warn('getGapsAndOverlapsDuration: No annotations found...')
			return []
		last = (1, minmax[0])
		lastP = 0
		for ts in xrange(*minmax):
			in1, in2 = isin(ts, spkr1anns), isin(ts, spkr2anns)
			if in1 and in2:		#Both speaking
				if last[0] == 'B': continue
				ty = 'B'
			elif in1:			#Only 1 speaking
				if last[0] == '1': continue
				ty = '1'
			elif in2:			#Only 2 speaking
				if last[0] == '2': continue
				ty = '2'
			else:				#None speaking
				if last[0] == 'N': continue
				ty = 'N'
			line1.append( (last[0], last[1], ts) )
			last = (ty, ts)
			if progressbar and int((ts*1.0/minmax[1])*100) > lastP:
				lastP = int((ts*1.0/minmax[1])*100)
				print '%d%%' % lastP
		line1.append((last[0], last[1], minmax[1]))
		ftos = []
		for i in xrange(len(line1)):
			if line1[i][0] == 'N':
				if i!=0 and i<len(line1)-1 and line1[i-1][0] != line1[i+1][0]:
					ftos.append(('G12_%s_%s' % (tier1, tier2) if line1[i-1][0]=='1' else 'G21_%s_%s' % (tier2, tier1), line1[i][1], line1[i][2]))
				else:
					ftos.append(('P_%s' % (tier1 if line1[i-1][0]=='1' else tier2), line1[i][1], line1[i][2]))
			elif line1[i][0] == 'B':
				if i!=0 and i<len(line1)-1 and line1[i-1][0] != line1[i+1][0]:
					ftos.append(('O12_%s_%s' % ((tier1, tier2) if line1[i-1][0] else 'O21_%s_%s' % (tier2, tier1)), line1[i][1], line1[i][2]))
				else:
					ftos.append(('B_%s_%s' % ((tier1, tier2) if line1[i-1][0]=='1' else (tier2, tier1)), line1[i][1], line1[i][2]))
		return [f for f in ftos if maxlen==-1 or abs(f[2]-f[1])<maxlen]

###LINGUISTIC TYPE FUNCTIONS
	def createControlledVocabulary(self, cvEntries, cvId, description=''):
		"""Adds a controlled vocabulary with the given cvEntiries{value->description}, id and optional description"""
		self.controlledvocabularies[cvId] = (description, cvEntries)

	def getTierIdsForLinguisticType(self, lingType, parent=None):
		"""Returns all the tier id's with the given linguistic type"""
		return [t for t in self.tiers if self.tiers[t][2]['LINGUISTIC_TYPE_REF']==lingType and (parent is None or self.tiers[t][2]['PARENT_REF']==parent)]

	def removeLinguisticType(self, lingType):
		"""Removes a linguistic type, returns 0 if succesfull"""
		try:
			del(self.linguistic_types[lingType])
			return 0
		except KeyError:
			warnings.warn('removeLinguisticType: Linguistic type non existent!')
			return 1

	def addLinguisticType(self, lingtype, constraints, timealignable=True, graphicreferences=False, extref=None):
		"""Adds a linguistic type, if it already exists the ling type is updated"""
		self.linguistic_types[lingtype] = {'LINGUISTIC_TYPE_ID':lingtype, 'TIME_ALIGNABLE':str(timealignable).lower(), 'GRAPHIC_REFERENCES':str(graphicreferences).lower(), 'CONSTRAINTS':constraints}
		if extref is not None:
			self.linguistic_types[lingtype]['EXT_REF'] = extref

	def getParameterDictForLinguisticType(self, lingid):
		"""Returns all the info of a lingtype in a dictionary, None if type doesn't exist"""
		try:
			return self.linguistic_types[lingid]
		except KeyError:
			warnings.warn('getParameterDictForLinguisticType: Linguistic type non existent!')
			return None

	def hasLinguisticType(self, lingtype):
		"""Returns if the given type is in the linguistic types"""
		return lingtype in self.linguistic_types
</code></pre>
    </div>

  <hr>

  <h2>Index</h2>

  <ul id="index">


    <li><h4><a href="#header-classes">Classes</a></h4>
      <ul>
          <li class="mono">
            <span class="class_name"><a href="#pympi.Elan.Eaf">Eaf</a></span>
            
              
  
  <div class="column_list">
      <ul>
          <li class="mono"><a href="#pympi.Elan.Eaf.__init__">__init__</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.addControlledVocabularyToLinguisticType">addControlledVocabularyToLinguisticType</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.addLinguisticType">addLinguisticType</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.addLinkedFile">addLinkedFile</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.addTier">addTier</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.childTiersFor">childTiersFor</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.cleanTimeSlots">cleanTimeSlots</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.copyTier">copyTier</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.createControlledVocabulary">createControlledVocabulary</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.createGapsAndOverlapsTier">createGapsAndOverlapsTier</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.extract">extract</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.filterAnnotations">filterAnnotations</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.generateAnnotationConcat">generateAnnotationConcat</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.generateAnnotationId">generateAnnotationId</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.generateTsId">generateTsId</a></li>
      </ul>
      <ul>
          <li class="mono"><a href="#pympi.Elan.Eaf.getAnnotationDataAtTime">getAnnotationDataAtTime</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.getAnnotationDataForTier">getAnnotationDataForTier</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.getAnnotationDatasBetweenTimes">getAnnotationDatasBetweenTimes</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.getFullTimeInterval">getFullTimeInterval</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.getGapsAndOverlapsDuration">getGapsAndOverlapsDuration</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.getIndexOfTier">getIndexOfTier</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.getLinguisticTypeForTier">getLinguisticTypeForTier</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.getLinkedFiles">getLinkedFiles</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.getLocaleForTier">getLocaleForTier</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.getParameterDictForLinguisticType">getParameterDictForLinguisticType</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.getParameterDictForTier">getParameterDictForTier</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.getParticipantForTier">getParticipantForTier</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.getRefAnnotationDataForTier">getRefAnnotationDataForTier</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.getTierIdsForLinguisticType">getTierIdsForLinguisticType</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.getTierNames">getTierNames</a></li>
      </ul>
      <ul>
          <li class="mono"><a href="#pympi.Elan.Eaf.getTimeSeries">getTimeSeries</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.glueAnnotationsInTier">glueAnnotationsInTier</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.hasLinguisticType">hasLinguisticType</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.insertAnnotation">insertAnnotation</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.insertRefAnnotation">insertRefAnnotation</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.mergeTiers">mergeTiers</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.removeAllAnnotationsFromTier">removeAllAnnotationsFromTier</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.removeAnnotation">removeAnnotation</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.removeControlledVocabulary">removeControlledVocabulary</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.removeLinguisticType">removeLinguisticType</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.removeTier">removeTier</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.removeTiers">removeTiers</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.shiftAnnotations">shiftAnnotations</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.toTextGrid">toTextGrid</a></li>
          <li class="mono"><a href="#pympi.Elan.Eaf.tofile">tofile</a></li>
      </ul>
  </div>

          </li>
      </ul>
    </li>

  </ul>



  <h2 id="header-classes">Classes</h2>
      
      <div class="item">
        <p id="pympi.Elan.Eaf" class="name">class <span class="ident">Eaf</span></p>
        
  
      <div class="desc"><p>Class to work with elan files
Class variables</p>
<hr />
<p>annotationDocument      - Dict of all annotationdocument TAG entries.
fileheader              - String of the header(xml version etc).
header                  - Dict of the header TAG entries.
media_descriptors       - List of all linked files: [{attrib}]
properties              - List of all properties: [(value, {attrib})]
linked_file_descriptors - List of all secondary linked files: [{attrib}].
timeslots               - Timeslot data: {TimslotID -&gt; time(ms)}
tiers                   - Tier data: {TierName -&gt; (alignedAnnotations, referenceAnnotations, attributes, ordinal)}, 
                                                        alignedAnnotations    : [{annotationId -&gt; (beginTs, endTs, value, svg_ref)}]
                                                        referenceAnnotations  : [{annotationId -&gt; (reference, value, previous, svg_ref)}]
linguistic_types        - Linguistic type data [{id -&gt; attrib}]
locales                 - List of locale data: [{attrib}]
constraints             - Constraint data: {stereotype -&gt; description}
controlled_vocabularies - Controlled vocabulary data: {id -&gt; (description, entries, ext_ref)}
                                                        entry: {description -&gt; (attrib, value)}
external refs           - External refs [extref]
                                                        extref: [id, type, value]
lexicon_refs            - Lexicon refs [{attribs}]</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf" class="source">
      <pre><code>class Eaf:
	"""Class to work with elan files
	Class variables
	---------------
	annotationDocument      - Dict of all annotationdocument TAG entries.
	fileheader              - String of the header(xml version etc).
	header                  - Dict of the header TAG entries.
	media_descriptors       - List of all linked files: [{attrib}]
	properties              - List of all properties: [(value, {attrib})]
	linked_file_descriptors - List of all secondary linked files: [{attrib}].
	timeslots               - Timeslot data: {TimslotID -> time(ms)}
	tiers                   - Tier data: {TierName -> (alignedAnnotations, referenceAnnotations, attributes, ordinal)}, 
								alignedAnnotations    : [{annotationId -> (beginTs, endTs, value, svg_ref)}]
								referenceAnnotations  : [{annotationId -> (reference, value, previous, svg_ref)}]
	linguistic_types        - Linguistic type data [{id -> attrib}]
	locales                 - List of locale data: [{attrib}]
	constraints             - Constraint data: {stereotype -> description}
	controlled_vocabularies - Controlled vocabulary data: {id -> (description, entries, ext_ref)}
								entry: {description -> (attrib, value)}
	external refs           - External refs [extref]
								extref: [id, type, value]
	lexicon_refs            - Lexicon refs [{attribs}]
	"""

###IO OPERATIONS
	def __init__(self, filePath=None, author='Elan.py', elan_new=True):
		"""Constructor, builds an elan object from file(if given) or an empty one, if elan_new is off then a true minimal file is created if it's on then default entries are added"""
		self.naiveGenAnn = False
		self.naiveGenTS = False
		now = localtime()
		self.annotationDocument = {
				'AUTHOR':author, 
				'DATE':'%.4d-%.2d-%.2dT%.2d:%.2d:%.2d+%.2d:00' % (now[0], now[1], now[2], now[3], now[4], now[5], now[8]), 
				'VERSION':'2.7', 
				'FORMAT':'2.7', 
				'xmlns:xsi':'http://www.w3.org/2001/XMLSchema-instance', 
				'xsi:noNamespaceSchemaLocation':'http://www.mpi.nl/tools/elan/EAFv2.7.xsd'}
		self.controlled_vocabularies, self.constraints, self.tiers, self.linguistic_types, self.header, self.timeslots = {}, {}, {}, {}, {}, {}
		self.external_refs, self.lexicon_refs, self.locales, self.media_descriptors, self.properties, self.linked_file_descriptors = [], [], [], [], [], []
		self.new_time, self.new_ann = 0, 0

		if filePath is None:
			self.addLinguisticType('default-lt', None)
			if elan_new:
				self.constraints = {'Time_Subdivision':'Time subdivision of parent annotation\'s time interval, no time gaps allowed within this interval',
						'Symbolic_Subdivision':'Symbolic subdivision of a parent annotation. Annotations refering to the same parent are ordered',
						'Symbolic_Association':'1-1 association with a parent annotation',
						'Included_In':'Time alignable annotations within the parent annotation\'s time interval, gaps are allowed'}
				self.properties.append(('0', {'NAME': 'lastUsedAnnotation'}))
				self.addTier('default')
		else:
			EafIO.parseEaf(filePath, self)

	def tofile(self, filePath, pretty=True):
		"""Exports the eaf object to a file given by the path, if pretty is false no indentation is used"""
		EafIO.toEaf(filePath, self)

	def toTextGrid(self, filePath, excludedTiers=[]):
		"""Converts the object to praat's TextGrid format and leaves the excludedTiers(optional) behind. returns 0 when succesfull"""
		try:
			from pympi.Praat import TextGrid
		except ImportError:
			warnings.warn('Please install the pympi.Praat module from the pympi module found at https://github.com/dopefishh/pympi')
			return 1
		tgout = TextGrid()
		for tier in [a for a in self.tiers if a not in excludedTiers]:
			currentTier = tgout.addTier(tier)
			for interval in self.getAnnotationDataForTier(tier):
				currentTier.addInterval(interval[0]/1000.0, interval[1]/1000.0, interval[2])
		tgout.tofile(filePath)
		return 0

	def extract(self, start, end):
		"""Extracts a timeframe from the eaf file and returns it"""
		from copy import deepcopy
		eafOut = deepcopy(self)
		for tier in eafOut.tiers.itervalues():
			rems = []
			for ann in tier[0]:
				if eafOut.timeslots[tier[0][ann][1]] > end or eafOut.timeslots[tier[0][ann][0]] < start:
					rems.append(ann)
			for r in rems:
				del tier[0][r]
		return eafOut

###MEDIA OPERATIONS
	def getTimeSeries(self):
		"""Gives a list of all time secondary linked txt files"""
		return [m for m in self.linked_file_descriptors if 'text/plain' in m['MIME_TYPE']]
	
	def getLinkedFiles(self):
		"""Gives a list of all media files"""
		return self.media_descriptors

	def addLinkedFile(self, filePath, relpath=None, mimetype=None, time_origin=None, exfrom=None):
		"""Adds the linked file, if the mimetype is not given it tries to find it(only words for mpg and wav"""
		if mimetype is None:
			mimes = {'wav':'audio/x-wav', 'mpg':'video/mpeg', 'mpeg':'video/mpg'}
			mimetype = mimes[filePath.split('.')[-1]]
		self.media_descriptors.append({'MEDIA_URL':filepath, 'RELATIVE_MEDIA_URL':relpath, 'MIME_TYPE':mimetype, 'TIME_ORIGIN':time_origin, 'EXTRACTED_FROM':exfrom})

###TIER OPERATIONS
	def copyTier(self, eafObj, tierName):
		"""Copies the tier from this object to the given object, if the tier is present it removes it. Returns 0 if succesfull"""
		eafObj.removeTier(tierName)
		try:
			t = self.tiers[tierName][3]
			eafObj.addTier(tierName, tierDict=self.tiers[tierName][3])
			for ann in self.getAnnotationDataForTier(tierName):
				eafObj.insertAnnotation(tierName, ann[0], ann[1], ann[2])
			return 0
		except KeyError:
			warnings.warn('copyTier: Tier non existent!')
			return 1

	def addTier(self, tierId, ling='default-lt', parent=None, locale=None, part=None, ann=None, tierDict=None):
		"""Adds a tier giving a id and type and optional extra data"""
		if tierDict is None:
			self.tiers[tierId] = ({}, {}, {'TIER_ID':tierId, 'LINGUISTIC_TYPE_REF':ling, 'PARENT_REF':parent, 'PARTICIPANT':part, 'DEFAULT_LOCALE':locale, 'ANNOTATOR':ann}, len(self.tiers))
		else:
			self.tiers[tierId] = ({}, {}, tierDict, len(self.tiers))

	def removeTiers(self, tiers):
		"""Removes the given tiers"""
		for a in tiers:
			self.removeTier(a, check=False, clean=False)
		self.cleanTimeSlots()

	def removeTier(self, idTier, check=False, clean=True):
		"""Removes a tier by id, returns 0 if succesfull"""
		try:
			del(self.tiers[idTier])
			if clean: 
				self.cleanTimeSlots()
			return 0
		except KeyError:	
			if check: warnings.warn('removeTier: Tier non existent!\n' + 'looking for: ' + idTier)
			return 1

	def getTierNames(self):
		"""Returns a list of tiernames"""
		return self.tiers.keys()

	def getIndexOfTier(self, idTier):
		"""Returns the index of a given tier, -1 if tier doesn't exist"""
		try:
			return self.tiers[idTier][3]
		except KeyError:
			warnings.warn('getIndexOfTier: Tier non existent!')
			return -1

	def getParameterDictForTier(self, idTier):
		"""Returns a dictionary with all the parameters of the given tier, None if tier doesn't exist"""
		try:
			return self.tiers[idTier][2]
		except KeyError:
			warnings.warn('getParameterDictForTier: Tier non existent!')
			return None

	def childTiersFor(self, idTier):
		"""Returns a list of all the children of the given tier, None if the tier doesn't exist"""
		try:
			return [m for m in self.tiers if 'PARENT_REF' in self.tiers[m][2] and self.tiers[m][2]['PARENT_REF']==idTier]
		except KeyError:
			warnings.warn('childTierFor: Tier non existent!')
			return None

	def getLinguisticTypeForTier(self, idTier):
		"""Returns the locale of the given tier, '' if none and None if tier doesn't exist"""
		try:
			return self.tiers[idTier][2]['LINGUISTIC_TYPE_REF']
		except KeyError:
			warnings.warn('getLinguisticTypeForTier: Tier non existent!')
			return None

	def getLocaleForTier(self, idTier):
		"""Returns the locale of the given tier, '' if none and None if tier doesn't exist"""
		try:
			tier = self.tiers[idTier]
			return '' if 'DEFAULT_LOCALE' not in tier[2] else tier[2]['DEFAULT_LOCALE']
		except KeyError:
			warnings.warn('getLocaleForTier: Tier non existent!')
			return None

	def getParticipantForTier(self, idTier):
		"""Returns the participant for the given tier, '' if none and None if tier doesn't exist"""
		try:
			tier = self.tiers[idTier]
			return '' if 'PARTICIPANT' not in tier[2] else tier[2]['PARTICIPANT']
		except KeyError:
			warnings.warn('getParticipantForTier: Tier non existent')
			return None

###ANNOTATION OPERATIONS
	def getAnnotationDataForTier(self, idTier):
		"""Returns the annotation data for the given tier in the format: (start, end, value)  None if the tier doesn't exist"""
		try:
			a = self.tiers[idTier][0]
			return [(self.timeslots[a[b][0]], self.timeslots[a[b][1]], a[b][2]) for b in a]
		except KeyError:
			warnings.warn('getAnnotationDataForTier: Tier non existent!')
			return None

	def getAnnotationDataAtTime(self, idTier, time):
		"""Returns an annotation at time in the given tier, None if the tier doesn't exist"""
		try:
			anns = self.tiers[idTier][0]
			return sorted([(self.timeslots[m[0]], self.timeslots[m[1]], m[2]) for m in anns.itervalues() if self.timeslots[m[0]]<=time and self.timeslots[m[1]]>=time])
		except KeyError:
			warnings.warn('getAnnotationDataAtTime: Tier non existent!')
			return None

	def getAnnotationDatasBetweenTimes(self, idTier, start, end):
		"""Returns all the annotations overlapping with the given interval in the given tier, None if the tier doesn't exist"""
		try:
			anns = self.tiers[idTier][0]
			return sorted([(self.timeslots[m[0]], self.timeslots[m[1]], m[2]) for m in anns.itervalues() if self.timeslots[m[1]]>=start and self.timeslots[m[0]]<=end])
		except KeyError:
			warnings.warn('getAnnotationDatasBetweenTimes: Tier non existent!')
			return None

	def removeAllAnnotationsFromTier(self, idTier):
		"""Removes all the annotations from the given tier, returns 0 if succesfull"""
		try:
			self.tiers[idTier][0], self.tiers[idTier][1] = {}, {}
			self.cleanTimeSlots()
			return 0
		except KeyError: 
			warnings.warn('removeAllAnnotationsFromTier: Tier non existent!')
			return 1

	def insertAnnotation(self, idTier, start, end, value='', svg_ref=None):
		"""Add an annotation in the given tier, returns 0 if succesfull"""
		try:
			startTs = self.generateTsId(start)
			endTs = self.generateTsId(end)
			self.tiers[idTier][0][self.generateAnnotationId()] = (startTs, endTs, value, svg_ref)
			return 0
		except KeyError:
			warnings.warn('insertAnnotation: Tier non existent')
			return 1
	
	def removeAnnotation(self, time, tier, clean=True):
		"""Removes an annotation at the given time point in the given tier, returns 0 if succesfull"""
		try:
			for b in [a for a in self.tiers[tier][0].iteritems() if a[1][0]>=time and a[1][1]<=time]:
				del(self.tiers[tier][0][b[0]])
				return 0
		except KeyError:
			warnings.warn('removeAnnotation: Tier non existent')
		return 1

	def insertRefAnnotation(self, idTier, ref, value, prev, svg_ref=None):
		"""Adds a reference annotation to the given tier, 0 if succesfull"""
		try:
			self.tiers[idTier][1][self.generateAnnotationId()] = (ref, value, prev, svg_ref)
			return 0
		except KeyError:
			warnings.warn('insertRefAnnotation: Tier non existent')
			return 1

	def getRefAnnotationDataForTier(self, idTier):
		"""Returns all the ref annotation for a given tier in the form: (id->(ref, value, prev, svg_ref), None if the tier doesn't exist"""
		try:
			return self.tiers[idTier][1]
		except KeyError:
			warnings.warn('getRefAnnotationDataForTier: Tier non existent!')
			return None

###CONTROLLED VOCABULARY OPERATIONS
	def addControlledVocabularyToLinguisticType(self, linguisticType, cvId):
		"""Adds a controlled vocabulary to a linguistic type, returns 0 if succesfull"""
		try:
			self.linguistic_types[linguisticType]['CONTROLLED_VOCABULARY_REF'] = cvId
			return 0
		except KeyError:
			warnings.warn('addControlledVocabularyToLinguisticType: Linguistic type non existent!')
			return 1

	def removeControlledVocabulary(self, cv):
		"""Removes a controlled vocabulary, returns 0 if succesfull"""
		try:
			del(self.controlled_vocabularies[cv])
			return 0
		except KeyError:
			warnings.warn('removeControlledVocabulary: Controlled vocabulary non existent!')
			return 1

###HELPER FUNCTIONS
	def generateAnnotationId(self):
		"""Helper function to generate the newest annotation id"""
		if self.naiveGenAnn:
			new = self.lastAnn+1
			self.lastAnn = new
		else:
			new = 1
			anns = {int(ann[1:]) for tier in self.tiers.itervalues() for ann in tier[0]}
			if len(anns) > 0:
				newann = set(xrange(1, max(anns))).difference(anns)
				if len(newann) == 0:
					new = max(anns)+1
					self.naiveGenAnn = True
					self.lastAnn = new
				else:
					new = sorted(newann)[0]
		return 'a%d' % new

	def generateTsId(self, time=None):
		"""Helper function te generate the newest timeslot id"""
		if self.naiveGenTS:
			new = self.lastTS+1
			self.lastTS = new
		else:
			new = 1
			tss = {int(x[2:]) for x in self.timeslots}
			if len(tss) > 0:
				newts = set(xrange(1, max(tss))).difference(tss)
				if len(newts) == 0:
					new = max(tss)+1
					self.naiveGenTS = True
					self.lastTS = new
				else:
					new = sorted(newts)[0]
		ts = 'ts%d' % new
		self.timeslots[ts] = time
		return ts

	def cleanTimeSlots(self):
		"""Removes all the unused timeslots"""
		tsInTier = set(sum([a[0:2] for tier in self.tiers.itervalues() for a in tier[0].itervalues()], ()))
		tsAvail = set(self.timeslots)
		for a in tsInTier.symmetric_difference(tsAvail):
			del(self.timeslots[a])
		self.naiveGenTS = False
		self.naiveGenAnn = False

###ADVANCED FUNCTIONS
	def generateAnnotationConcat(self, tiers, start, end):
		"""Generates a general value combining all the unique values within the tiers given"""
		return '_'.join(set(d[2] for t in tiers if t in self.tiers for d in self.getAnnotationDatasBetweenTimes(t, start, end)))

	def mergeTiers(self, tiers, tiernew=None, gaptresh=1):
		"""Merges the given tiers together in the new tier, returns 0 if succesfull"""
		if len([t for t in tiers if t not in self.tiers]) > 0:
			warnings.warn('mergeTiers: One or more tiers non existent!')
			return 1        
		if tiernew is None: 
			tiernew = '%s_Merged' % '_'.join(tiers)
		self.removeTier(tiernew)
		self.addTier(tiernew)
		try:
			timepts = sorted(set.union(\
			*[set(j for j in xrange(d[0], d[1])) for d in\
			[ann for tier in tiers for ann in self.getAnnotationDataForTier(tier)]]))
		except TypeError:
			warnings.warn('mergeTiers: No annotations found!')
			return 1
		if len(timepts) > 1:
			start = timepts[0]
			for i in xrange(1, len(timepts)):
				if timepts[i]-timepts[i-1] > gaptresh:
					self.insertAnnotation(tiernew, start, timepts[i-1], self.generateAnnotationConcat(tiers, start, timepts[i-1]))
					start = timepts[i]
			self.insertAnnotation(tiernew, start, timepts[i-1], self.generateAnnotationConcat(tiers, start, timepts[i-1]))
		return 0

	def shiftAnnotations(self, time):
		"""Returns a copy of the object with the timeshift of the desired ms (negative for right shift, positive for left shift)"""
		e = self.extract(-1*time, self.getFullTimeInterval()[1]) if time < 0 else self.extract(0, self.getFullTimeInterval()[1]-time)
		for tier in e.tiers.itervalues():
			for ann in tier[0].itervalues():
				e.timeslots[ann[0]],e.timeslots[ann[1]] = e.timeslots[ann[0]]+offset, e.timeslots[ann[1]]+offset
		e.cleanTimeSlots()
		return e

	def filterAnnotations(self, tier, tierName=None, filtin=None, filtex=None):
		"""Filters the tier, retuns 0 when succesfull"""
		if tier not in self.tiers:
			warnings.warn('filterAnnotations: Tier non existent!' + tier)
			return 1
		if tierName is None:
			tierName = '%s_filter' % tier1
		self.removeTier(tierName)
		self.addTier(tierName)
		for a in [b for b in self.getAnnotationDataForTier(tier) if (filtex is None or b[2] not in filtex) and (filtin is None or b[2] in filtin)]:
			self.insertAnnotation(tierName, a[0], a[1], a[2])
		return 0

	def glueAnnotationsInTier(self, tier, tierName=None, treshhold=85, filtin=None, filtex=None):
		"""Glues all the continues annotations together, returns 0 if succesfull"""
		if tier not in self.tiers:
			warnings.warn('glueAnnotationsInTier: Tier non existent!')
			return 1
		if tierName is None: 
			tierName = '%s_glued' % tier
		self.removeTier(tierName)
		self.addTier(tierName)
		tierData = sorted(self.getAnnotationDataForTier(tier), key=lambda a: a[0])
		tierData = [t for t in tierData if (filtin is None or t[2] in filtin) and (filtex is None or t[2] not in filtex)]
		currentAnn = None
		for i in xrange(0, len(tierData)):
			if currentAnn is None:
				currentAnn = (tierData[i][0], tierData[i][1], tierData[i][2])
			elif tierData[i][0]-currentAnn[1]<treshhold:
				currentAnn = (currentAnn[0], tierData[i][1], '%s_%s' % (currentAnn[2], tierData[i][2]))
			else:
				self.insertAnnotation(tierName, currentAnn[0], currentAnn[1], currentAnn[2])
				currentAnn = tierData[i]
		if currentAnn is not None:
			self.insertAnnotation(tierName, currentAnn[0], tierData[len(tierData)-1][1], currentAnn[2])
		return 0

	def getFullTimeInterval(self):
		"""Returns a tuple (start, end) of the full time frame"""
		return (min(self.timeslots.itervalues()), max(self.timeslots.itervalues()))

	def createGapsAndOverlapsTier(self, tier1, tier2, tierName=None, maxlen=-1, tierType=None):
		"""Creates a tier out of the gaps and overlap between two tiers, returns the fto data, returns None if one of the tiers doesn't exist"""
		if tier1 not in self.tiers or tier2 not in self.tiers:
			warnings.warn('createGapsAndOverlapsTier: One or more tiers non existent!')
			return None
		if tierName is None:
			tierName = '%s_%s_ftos' % (tier1, tier2)
		self.removeTier(tierName)
		self.addTier(tierName)
		ftos = self.getGapsAndOverlapsDuration(tier1, tier2, maxlen)
		for fto in ftos:
			self.insertAnnotation(tierName, fto[1], fto[2], fto[0])
		return ftos

	def getGapsAndOverlapsDuration(self, tier1, tier2, maxlen=-1, progressbar=False):
		"""Gives the gaps and overlaps between tiers in the format: (type, start, end), None if one of the tiers don't exist."""
		if tier1 not in self.tiers or tier2 not in self.tiers: 
			warnings.warn('getGapsAndOverlapsDuration: One or more tiers non existent!')
			return None
		spkr1anns = sorted((self.timeslots[a[0]], self.timeslots[a[1]]) for a in self.tiers[tier1][0].values())
		spkr2anns = sorted((self.timeslots[a[0]], self.timeslots[a[1]]) for a in self.tiers[tier2][0].values())
		line1 = []
		isin = lambda x, lst: False if len([i for i in lst if i[0]<=x and i[1]>=x])==0 else True
		try:
			minmax = (min(spkr1anns[0][0], spkr2anns[0][0]), max(spkr1anns[-1][1], spkr2anns[-1][1]))
		except IndexError:
			warnings.warn('getGapsAndOverlapsDuration: No annotations found...')
			return []
		last = (1, minmax[0])
		lastP = 0
		for ts in xrange(*minmax):
			in1, in2 = isin(ts, spkr1anns), isin(ts, spkr2anns)
			if in1 and in2:		#Both speaking
				if last[0] == 'B': continue
				ty = 'B'
			elif in1:			#Only 1 speaking
				if last[0] == '1': continue
				ty = '1'
			elif in2:			#Only 2 speaking
				if last[0] == '2': continue
				ty = '2'
			else:				#None speaking
				if last[0] == 'N': continue
				ty = 'N'
			line1.append( (last[0], last[1], ts) )
			last = (ty, ts)
			if progressbar and int((ts*1.0/minmax[1])*100) > lastP:
				lastP = int((ts*1.0/minmax[1])*100)
				print '%d%%' % lastP
		line1.append((last[0], last[1], minmax[1]))
		ftos = []
		for i in xrange(len(line1)):
			if line1[i][0] == 'N':
				if i!=0 and i<len(line1)-1 and line1[i-1][0] != line1[i+1][0]:
					ftos.append(('G12_%s_%s' % (tier1, tier2) if line1[i-1][0]=='1' else 'G21_%s_%s' % (tier2, tier1), line1[i][1], line1[i][2]))
				else:
					ftos.append(('P_%s' % (tier1 if line1[i-1][0]=='1' else tier2), line1[i][1], line1[i][2]))
			elif line1[i][0] == 'B':
				if i!=0 and i<len(line1)-1 and line1[i-1][0] != line1[i+1][0]:
					ftos.append(('O12_%s_%s' % ((tier1, tier2) if line1[i-1][0] else 'O21_%s_%s' % (tier2, tier1)), line1[i][1], line1[i][2]))
				else:
					ftos.append(('B_%s_%s' % ((tier1, tier2) if line1[i-1][0]=='1' else (tier2, tier1)), line1[i][1], line1[i][2]))
		return [f for f in ftos if maxlen==-1 or abs(f[2]-f[1])<maxlen]

###LINGUISTIC TYPE FUNCTIONS
	def createControlledVocabulary(self, cvEntries, cvId, description=''):
		"""Adds a controlled vocabulary with the given cvEntiries{value->description}, id and optional description"""
		self.controlledvocabularies[cvId] = (description, cvEntries)

	def getTierIdsForLinguisticType(self, lingType, parent=None):
		"""Returns all the tier id's with the given linguistic type"""
		return [t for t in self.tiers if self.tiers[t][2]['LINGUISTIC_TYPE_REF']==lingType and (parent is None or self.tiers[t][2]['PARENT_REF']==parent)]

	def removeLinguisticType(self, lingType):
		"""Removes a linguistic type, returns 0 if succesfull"""
		try:
			del(self.linguistic_types[lingType])
			return 0
		except KeyError:
			warnings.warn('removeLinguisticType: Linguistic type non existent!')
			return 1

	def addLinguisticType(self, lingtype, constraints, timealignable=True, graphicreferences=False, extref=None):
		"""Adds a linguistic type, if it already exists the ling type is updated"""
		self.linguistic_types[lingtype] = {'LINGUISTIC_TYPE_ID':lingtype, 'TIME_ALIGNABLE':str(timealignable).lower(), 'GRAPHIC_REFERENCES':str(graphicreferences).lower(), 'CONSTRAINTS':constraints}
		if extref is not None:
			self.linguistic_types[lingtype]['EXT_REF'] = extref

	def getParameterDictForLinguisticType(self, lingid):
		"""Returns all the info of a lingtype in a dictionary, None if type doesn't exist"""
		try:
			return self.linguistic_types[lingid]
		except KeyError:
			warnings.warn('getParameterDictForLinguisticType: Linguistic type non existent!')
			return None

	def hasLinguisticType(self, lingtype):
		"""Returns if the given type is in the linguistic types"""
		return lingtype in self.linguistic_types
</code></pre>
    </div>
</div>


        <div class="class">
              <h4>Ancestors (in MRO)</h4>
              <ul class="class_list">
                <li><a href="#pympi.Elan.Eaf">Eaf</a></li>
              </ul>
              <h4>Instance variables</h4>
                  <div class="item">
                    <p id="pympi.Elan.Eaf.annotationDocument" class="name">var <span class="ident">annotationDocument</span></p>
                    

                    
  
    <div class="source_cont">
</div>

                  </div>
                  <div class="item">
                    <p id="pympi.Elan.Eaf.naiveGenAnn" class="name">var <span class="ident">naiveGenAnn</span></p>
                    

                    
  
    <div class="source_cont">
</div>

                  </div>
                  <div class="item">
                    <p id="pympi.Elan.Eaf.naiveGenTS" class="name">var <span class="ident">naiveGenTS</span></p>
                    

                    
  
    <div class="source_cont">
</div>

                  </div>
              <h4>Methods</h4>
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.__init__">
        <p>def <span class="ident">__init__</span>(</p><p>self, filePath=None, author='Elan.py', elan_new=True)</p>
      </div>
      

      
  
      <div class="desc"><p>Constructor, builds an elan object from file(if given) or an empty one, if elan_new is off then a true minimal file is created if it's on then default entries are added</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.__init__', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.__init__" class="source">
      <pre><code>def __init__(self, filePath=None, author='Elan.py', elan_new=True):
	"""Constructor, builds an elan object from file(if given) or an empty one, if elan_new is off then a true minimal file is created if it's on then default entries are added"""
	self.naiveGenAnn = False
	self.naiveGenTS = False
	now = localtime()
	self.annotationDocument = {
			'AUTHOR':author, 
			'DATE':'%.4d-%.2d-%.2dT%.2d:%.2d:%.2d+%.2d:00' % (now[0], now[1], now[2], now[3], now[4], now[5], now[8]), 
			'VERSION':'2.7', 
			'FORMAT':'2.7', 
			'xmlns:xsi':'http://www.w3.org/2001/XMLSchema-instance', 
			'xsi:noNamespaceSchemaLocation':'http://www.mpi.nl/tools/elan/EAFv2.7.xsd'}
	self.controlled_vocabularies, self.constraints, self.tiers, self.linguistic_types, self.header, self.timeslots = {}, {}, {}, {}, {}, {}
	self.external_refs, self.lexicon_refs, self.locales, self.media_descriptors, self.properties, self.linked_file_descriptors = [], [], [], [], [], []
	self.new_time, self.new_ann = 0, 0
	if filePath is None:
		self.addLinguisticType('default-lt', None)
		if elan_new:
			self.constraints = {'Time_Subdivision':'Time subdivision of parent annotation\'s time interval, no time gaps allowed within this interval',
					'Symbolic_Subdivision':'Symbolic subdivision of a parent annotation. Annotations refering to the same parent are ordered',
					'Symbolic_Association':'1-1 association with a parent annotation',
					'Included_In':'Time alignable annotations within the parent annotation\'s time interval, gaps are allowed'}
			self.properties.append(('0', {'NAME': 'lastUsedAnnotation'}))
			self.addTier('default')
	else:
		EafIO.parseEaf(filePath, self)
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.addControlledVocabularyToLinguisticType">
        <p>def <span class="ident">addControlledVocabularyToLinguisticType</span>(</p><p>self, linguisticType, cvId)</p>
      </div>
      

      
  
      <div class="desc"><p>Adds a controlled vocabulary to a linguistic type, returns 0 if succesfull</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.addControlledVocabularyToLinguisticType', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.addControlledVocabularyToLinguisticType" class="source">
      <pre><code>def addControlledVocabularyToLinguisticType(self, linguisticType, cvId):
	"""Adds a controlled vocabulary to a linguistic type, returns 0 if succesfull"""
	try:
		self.linguistic_types[linguisticType]['CONTROLLED_VOCABULARY_REF'] = cvId
		return 0
	except KeyError:
		warnings.warn('addControlledVocabularyToLinguisticType: Linguistic type non existent!')
		return 1
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.addLinguisticType">
        <p>def <span class="ident">addLinguisticType</span>(</p><p>self, lingtype, constraints, timealignable=True, graphicreferences=False, extref=None)</p>
      </div>
      

      
  
      <div class="desc"><p>Adds a linguistic type, if it already exists the ling type is updated</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.addLinguisticType', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.addLinguisticType" class="source">
      <pre><code>def addLinguisticType(self, lingtype, constraints, timealignable=True, graphicreferences=False, extref=None):
	"""Adds a linguistic type, if it already exists the ling type is updated"""
	self.linguistic_types[lingtype] = {'LINGUISTIC_TYPE_ID':lingtype, 'TIME_ALIGNABLE':str(timealignable).lower(), 'GRAPHIC_REFERENCES':str(graphicreferences).lower(), 'CONSTRAINTS':constraints}
	if extref is not None:
		self.linguistic_types[lingtype]['EXT_REF'] = extref
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.addLinkedFile">
        <p>def <span class="ident">addLinkedFile</span>(</p><p>self, filePath, relpath=None, mimetype=None, time_origin=None, exfrom=None)</p>
      </div>
      

      
  
      <div class="desc"><p>Adds the linked file, if the mimetype is not given it tries to find it(only words for mpg and wav</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.addLinkedFile', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.addLinkedFile" class="source">
      <pre><code>def addLinkedFile(self, filePath, relpath=None, mimetype=None, time_origin=None, exfrom=None):
	"""Adds the linked file, if the mimetype is not given it tries to find it(only words for mpg and wav"""
	if mimetype is None:
		mimes = {'wav':'audio/x-wav', 'mpg':'video/mpeg', 'mpeg':'video/mpg'}
		mimetype = mimes[filePath.split('.')[-1]]
	self.media_descriptors.append({'MEDIA_URL':filepath, 'RELATIVE_MEDIA_URL':relpath, 'MIME_TYPE':mimetype, 'TIME_ORIGIN':time_origin, 'EXTRACTED_FROM':exfrom})
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.addTier">
        <p>def <span class="ident">addTier</span>(</p><p>self, tierId, ling='default-lt', parent=None, locale=None, part=None, ann=None, tierDict=None)</p>
      </div>
      

      
  
      <div class="desc"><p>Adds a tier giving a id and type and optional extra data</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.addTier', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.addTier" class="source">
      <pre><code>def addTier(self, tierId, ling='default-lt', parent=None, locale=None, part=None, ann=None, tierDict=None):
	"""Adds a tier giving a id and type and optional extra data"""
	if tierDict is None:
		self.tiers[tierId] = ({}, {}, {'TIER_ID':tierId, 'LINGUISTIC_TYPE_REF':ling, 'PARENT_REF':parent, 'PARTICIPANT':part, 'DEFAULT_LOCALE':locale, 'ANNOTATOR':ann}, len(self.tiers))
	else:
		self.tiers[tierId] = ({}, {}, tierDict, len(self.tiers))
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.childTiersFor">
        <p>def <span class="ident">childTiersFor</span>(</p><p>self, idTier)</p>
      </div>
      

      
  
      <div class="desc"><p>Returns a list of all the children of the given tier, None if the tier doesn't exist</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.childTiersFor', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.childTiersFor" class="source">
      <pre><code>def childTiersFor(self, idTier):
	"""Returns a list of all the children of the given tier, None if the tier doesn't exist"""
	try:
		return [m for m in self.tiers if 'PARENT_REF' in self.tiers[m][2] and self.tiers[m][2]['PARENT_REF']==idTier]
	except KeyError:
		warnings.warn('childTierFor: Tier non existent!')
		return None
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.cleanTimeSlots">
        <p>def <span class="ident">cleanTimeSlots</span>(</p><p>self)</p>
      </div>
      

      
  
      <div class="desc"><p>Removes all the unused timeslots</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.cleanTimeSlots', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.cleanTimeSlots" class="source">
      <pre><code>def cleanTimeSlots(self):
	"""Removes all the unused timeslots"""
	tsInTier = set(sum([a[0:2] for tier in self.tiers.itervalues() for a in tier[0].itervalues()], ()))
	tsAvail = set(self.timeslots)
	for a in tsInTier.symmetric_difference(tsAvail):
		del(self.timeslots[a])
	self.naiveGenTS = False
	self.naiveGenAnn = False
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.copyTier">
        <p>def <span class="ident">copyTier</span>(</p><p>self, eafObj, tierName)</p>
      </div>
      

      
  
      <div class="desc"><p>Copies the tier from this object to the given object, if the tier is present it removes it. Returns 0 if succesfull</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.copyTier', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.copyTier" class="source">
      <pre><code>def copyTier(self, eafObj, tierName):
	"""Copies the tier from this object to the given object, if the tier is present it removes it. Returns 0 if succesfull"""
	eafObj.removeTier(tierName)
	try:
		t = self.tiers[tierName][3]
		eafObj.addTier(tierName, tierDict=self.tiers[tierName][3])
		for ann in self.getAnnotationDataForTier(tierName):
			eafObj.insertAnnotation(tierName, ann[0], ann[1], ann[2])
		return 0
	except KeyError:
		warnings.warn('copyTier: Tier non existent!')
		return 1
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.createControlledVocabulary">
        <p>def <span class="ident">createControlledVocabulary</span>(</p><p>self, cvEntries, cvId, description='')</p>
      </div>
      

      
  
      <div class="desc"><p>Adds a controlled vocabulary with the given cvEntiries{value-&gt;description}, id and optional description</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.createControlledVocabulary', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.createControlledVocabulary" class="source">
      <pre><code>def createControlledVocabulary(self, cvEntries, cvId, description=''):
	"""Adds a controlled vocabulary with the given cvEntiries{value->description}, id and optional description"""
	self.controlledvocabularies[cvId] = (description, cvEntries)
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.createGapsAndOverlapsTier">
        <p>def <span class="ident">createGapsAndOverlapsTier</span>(</p><p>self, tier1, tier2, tierName=None, maxlen=-1, tierType=None)</p>
      </div>
      

      
  
      <div class="desc"><p>Creates a tier out of the gaps and overlap between two tiers, returns the fto data, returns None if one of the tiers doesn't exist</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.createGapsAndOverlapsTier', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.createGapsAndOverlapsTier" class="source">
      <pre><code>def createGapsAndOverlapsTier(self, tier1, tier2, tierName=None, maxlen=-1, tierType=None):
	"""Creates a tier out of the gaps and overlap between two tiers, returns the fto data, returns None if one of the tiers doesn't exist"""
	if tier1 not in self.tiers or tier2 not in self.tiers:
		warnings.warn('createGapsAndOverlapsTier: One or more tiers non existent!')
		return None
	if tierName is None:
		tierName = '%s_%s_ftos' % (tier1, tier2)
	self.removeTier(tierName)
	self.addTier(tierName)
	ftos = self.getGapsAndOverlapsDuration(tier1, tier2, maxlen)
	for fto in ftos:
		self.insertAnnotation(tierName, fto[1], fto[2], fto[0])
	return ftos
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.extract">
        <p>def <span class="ident">extract</span>(</p><p>self, start, end)</p>
      </div>
      

      
  
      <div class="desc"><p>Extracts a timeframe from the eaf file and returns it</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.extract', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.extract" class="source">
      <pre><code>def extract(self, start, end):
	"""Extracts a timeframe from the eaf file and returns it"""
	from copy import deepcopy
	eafOut = deepcopy(self)
	for tier in eafOut.tiers.itervalues():
		rems = []
		for ann in tier[0]:
			if eafOut.timeslots[tier[0][ann][1]] > end or eafOut.timeslots[tier[0][ann][0]] < start:
				rems.append(ann)
		for r in rems:
			del tier[0][r]
	return eafOut
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.filterAnnotations">
        <p>def <span class="ident">filterAnnotations</span>(</p><p>self, tier, tierName=None, filtin=None, filtex=None)</p>
      </div>
      

      
  
      <div class="desc"><p>Filters the tier, retuns 0 when succesfull</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.filterAnnotations', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.filterAnnotations" class="source">
      <pre><code>def filterAnnotations(self, tier, tierName=None, filtin=None, filtex=None):
	"""Filters the tier, retuns 0 when succesfull"""
	if tier not in self.tiers:
		warnings.warn('filterAnnotations: Tier non existent!' + tier)
		return 1
	if tierName is None:
		tierName = '%s_filter' % tier1
	self.removeTier(tierName)
	self.addTier(tierName)
	for a in [b for b in self.getAnnotationDataForTier(tier) if (filtex is None or b[2] not in filtex) and (filtin is None or b[2] in filtin)]:
		self.insertAnnotation(tierName, a[0], a[1], a[2])
	return 0
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.generateAnnotationConcat">
        <p>def <span class="ident">generateAnnotationConcat</span>(</p><p>self, tiers, start, end)</p>
      </div>
      

      
  
      <div class="desc"><p>Generates a general value combining all the unique values within the tiers given</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.generateAnnotationConcat', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.generateAnnotationConcat" class="source">
      <pre><code>def generateAnnotationConcat(self, tiers, start, end):
	"""Generates a general value combining all the unique values within the tiers given"""
	return '_'.join(set(d[2] for t in tiers if t in self.tiers for d in self.getAnnotationDatasBetweenTimes(t, start, end)))
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.generateAnnotationId">
        <p>def <span class="ident">generateAnnotationId</span>(</p><p>self)</p>
      </div>
      

      
  
      <div class="desc"><p>Helper function to generate the newest annotation id</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.generateAnnotationId', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.generateAnnotationId" class="source">
      <pre><code>def generateAnnotationId(self):
	"""Helper function to generate the newest annotation id"""
	if self.naiveGenAnn:
		new = self.lastAnn+1
		self.lastAnn = new
	else:
		new = 1
		anns = {int(ann[1:]) for tier in self.tiers.itervalues() for ann in tier[0]}
		if len(anns) > 0:
			newann = set(xrange(1, max(anns))).difference(anns)
			if len(newann) == 0:
				new = max(anns)+1
				self.naiveGenAnn = True
				self.lastAnn = new
			else:
				new = sorted(newann)[0]
	return 'a%d' % new
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.generateTsId">
        <p>def <span class="ident">generateTsId</span>(</p><p>self, time=None)</p>
      </div>
      

      
  
      <div class="desc"><p>Helper function te generate the newest timeslot id</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.generateTsId', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.generateTsId" class="source">
      <pre><code>def generateTsId(self, time=None):
	"""Helper function te generate the newest timeslot id"""
	if self.naiveGenTS:
		new = self.lastTS+1
		self.lastTS = new
	else:
		new = 1
		tss = {int(x[2:]) for x in self.timeslots}
		if len(tss) > 0:
			newts = set(xrange(1, max(tss))).difference(tss)
			if len(newts) == 0:
				new = max(tss)+1
				self.naiveGenTS = True
				self.lastTS = new
			else:
				new = sorted(newts)[0]
	ts = 'ts%d' % new
	self.timeslots[ts] = time
	return ts
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.getAnnotationDataAtTime">
        <p>def <span class="ident">getAnnotationDataAtTime</span>(</p><p>self, idTier, time)</p>
      </div>
      

      
  
      <div class="desc"><p>Returns an annotation at time in the given tier, None if the tier doesn't exist</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.getAnnotationDataAtTime', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.getAnnotationDataAtTime" class="source">
      <pre><code>def getAnnotationDataAtTime(self, idTier, time):
	"""Returns an annotation at time in the given tier, None if the tier doesn't exist"""
	try:
		anns = self.tiers[idTier][0]
		return sorted([(self.timeslots[m[0]], self.timeslots[m[1]], m[2]) for m in anns.itervalues() if self.timeslots[m[0]]<=time and self.timeslots[m[1]]>=time])
	except KeyError:
		warnings.warn('getAnnotationDataAtTime: Tier non existent!')
		return None
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.getAnnotationDataForTier">
        <p>def <span class="ident">getAnnotationDataForTier</span>(</p><p>self, idTier)</p>
      </div>
      

      
  
      <div class="desc"><p>Returns the annotation data for the given tier in the format: (start, end, value)  None if the tier doesn't exist</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.getAnnotationDataForTier', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.getAnnotationDataForTier" class="source">
      <pre><code>def getAnnotationDataForTier(self, idTier):
	"""Returns the annotation data for the given tier in the format: (start, end, value)  None if the tier doesn't exist"""
	try:
		a = self.tiers[idTier][0]
		return [(self.timeslots[a[b][0]], self.timeslots[a[b][1]], a[b][2]) for b in a]
	except KeyError:
		warnings.warn('getAnnotationDataForTier: Tier non existent!')
		return None
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.getAnnotationDatasBetweenTimes">
        <p>def <span class="ident">getAnnotationDatasBetweenTimes</span>(</p><p>self, idTier, start, end)</p>
      </div>
      

      
  
      <div class="desc"><p>Returns all the annotations overlapping with the given interval in the given tier, None if the tier doesn't exist</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.getAnnotationDatasBetweenTimes', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.getAnnotationDatasBetweenTimes" class="source">
      <pre><code>def getAnnotationDatasBetweenTimes(self, idTier, start, end):
	"""Returns all the annotations overlapping with the given interval in the given tier, None if the tier doesn't exist"""
	try:
		anns = self.tiers[idTier][0]
		return sorted([(self.timeslots[m[0]], self.timeslots[m[1]], m[2]) for m in anns.itervalues() if self.timeslots[m[1]]>=start and self.timeslots[m[0]]<=end])
	except KeyError:
		warnings.warn('getAnnotationDatasBetweenTimes: Tier non existent!')
		return None
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.getFullTimeInterval">
        <p>def <span class="ident">getFullTimeInterval</span>(</p><p>self)</p>
      </div>
      

      
  
      <div class="desc"><p>Returns a tuple (start, end) of the full time frame</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.getFullTimeInterval', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.getFullTimeInterval" class="source">
      <pre><code>def getFullTimeInterval(self):
	"""Returns a tuple (start, end) of the full time frame"""
	return (min(self.timeslots.itervalues()), max(self.timeslots.itervalues()))
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.getGapsAndOverlapsDuration">
        <p>def <span class="ident">getGapsAndOverlapsDuration</span>(</p><p>self, tier1, tier2, maxlen=-1, progressbar=False)</p>
      </div>
      

      
  
      <div class="desc"><p>Gives the gaps and overlaps between tiers in the format: (type, start, end), None if one of the tiers don't exist.</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.getGapsAndOverlapsDuration', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.getGapsAndOverlapsDuration" class="source">
      <pre><code>def getGapsAndOverlapsDuration(self, tier1, tier2, maxlen=-1, progressbar=False):
	"""Gives the gaps and overlaps between tiers in the format: (type, start, end), None if one of the tiers don't exist."""
	if tier1 not in self.tiers or tier2 not in self.tiers: 
		warnings.warn('getGapsAndOverlapsDuration: One or more tiers non existent!')
		return None
	spkr1anns = sorted((self.timeslots[a[0]], self.timeslots[a[1]]) for a in self.tiers[tier1][0].values())
	spkr2anns = sorted((self.timeslots[a[0]], self.timeslots[a[1]]) for a in self.tiers[tier2][0].values())
	line1 = []
	isin = lambda x, lst: False if len([i for i in lst if i[0]<=x and i[1]>=x])==0 else True
	try:
		minmax = (min(spkr1anns[0][0], spkr2anns[0][0]), max(spkr1anns[-1][1], spkr2anns[-1][1]))
	except IndexError:
		warnings.warn('getGapsAndOverlapsDuration: No annotations found...')
		return []
	last = (1, minmax[0])
	lastP = 0
	for ts in xrange(*minmax):
		in1, in2 = isin(ts, spkr1anns), isin(ts, spkr2anns)
		if in1 and in2:		#Both speaking
			if last[0] == 'B': continue
			ty = 'B'
		elif in1:			#Only 1 speaking
			if last[0] == '1': continue
			ty = '1'
		elif in2:			#Only 2 speaking
			if last[0] == '2': continue
			ty = '2'
		else:				#None speaking
			if last[0] == 'N': continue
			ty = 'N'
		line1.append( (last[0], last[1], ts) )
		last = (ty, ts)
		if progressbar and int((ts*1.0/minmax[1])*100) > lastP:
			lastP = int((ts*1.0/minmax[1])*100)
			print '%d%%' % lastP
	line1.append((last[0], last[1], minmax[1]))
	ftos = []
	for i in xrange(len(line1)):
		if line1[i][0] == 'N':
			if i!=0 and i<len(line1)-1 and line1[i-1][0] != line1[i+1][0]:
				ftos.append(('G12_%s_%s' % (tier1, tier2) if line1[i-1][0]=='1' else 'G21_%s_%s' % (tier2, tier1), line1[i][1], line1[i][2]))
			else:
				ftos.append(('P_%s' % (tier1 if line1[i-1][0]=='1' else tier2), line1[i][1], line1[i][2]))
		elif line1[i][0] == 'B':
			if i!=0 and i<len(line1)-1 and line1[i-1][0] != line1[i+1][0]:
				ftos.append(('O12_%s_%s' % ((tier1, tier2) if line1[i-1][0] else 'O21_%s_%s' % (tier2, tier1)), line1[i][1], line1[i][2]))
			else:
				ftos.append(('B_%s_%s' % ((tier1, tier2) if line1[i-1][0]=='1' else (tier2, tier1)), line1[i][1], line1[i][2]))
	return [f for f in ftos if maxlen==-1 or abs(f[2]-f[1])<maxlen]
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.getIndexOfTier">
        <p>def <span class="ident">getIndexOfTier</span>(</p><p>self, idTier)</p>
      </div>
      

      
  
      <div class="desc"><p>Returns the index of a given tier, -1 if tier doesn't exist</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.getIndexOfTier', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.getIndexOfTier" class="source">
      <pre><code>def getIndexOfTier(self, idTier):
	"""Returns the index of a given tier, -1 if tier doesn't exist"""
	try:
		return self.tiers[idTier][3]
	except KeyError:
		warnings.warn('getIndexOfTier: Tier non existent!')
		return -1
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.getLinguisticTypeForTier">
        <p>def <span class="ident">getLinguisticTypeForTier</span>(</p><p>self, idTier)</p>
      </div>
      

      
  
      <div class="desc"><p>Returns the locale of the given tier, '' if none and None if tier doesn't exist</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.getLinguisticTypeForTier', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.getLinguisticTypeForTier" class="source">
      <pre><code>def getLinguisticTypeForTier(self, idTier):
	"""Returns the locale of the given tier, '' if none and None if tier doesn't exist"""
	try:
		return self.tiers[idTier][2]['LINGUISTIC_TYPE_REF']
	except KeyError:
		warnings.warn('getLinguisticTypeForTier: Tier non existent!')
		return None
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.getLinkedFiles">
        <p>def <span class="ident">getLinkedFiles</span>(</p><p>self)</p>
      </div>
      

      
  
      <div class="desc"><p>Gives a list of all media files</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.getLinkedFiles', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.getLinkedFiles" class="source">
      <pre><code>def getLinkedFiles(self):
	"""Gives a list of all media files"""
	return self.media_descriptors
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.getLocaleForTier">
        <p>def <span class="ident">getLocaleForTier</span>(</p><p>self, idTier)</p>
      </div>
      

      
  
      <div class="desc"><p>Returns the locale of the given tier, '' if none and None if tier doesn't exist</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.getLocaleForTier', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.getLocaleForTier" class="source">
      <pre><code>def getLocaleForTier(self, idTier):
	"""Returns the locale of the given tier, '' if none and None if tier doesn't exist"""
	try:
		tier = self.tiers[idTier]
		return '' if 'DEFAULT_LOCALE' not in tier[2] else tier[2]['DEFAULT_LOCALE']
	except KeyError:
		warnings.warn('getLocaleForTier: Tier non existent!')
		return None
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.getParameterDictForLinguisticType">
        <p>def <span class="ident">getParameterDictForLinguisticType</span>(</p><p>self, lingid)</p>
      </div>
      

      
  
      <div class="desc"><p>Returns all the info of a lingtype in a dictionary, None if type doesn't exist</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.getParameterDictForLinguisticType', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.getParameterDictForLinguisticType" class="source">
      <pre><code>def getParameterDictForLinguisticType(self, lingid):
	"""Returns all the info of a lingtype in a dictionary, None if type doesn't exist"""
	try:
		return self.linguistic_types[lingid]
	except KeyError:
		warnings.warn('getParameterDictForLinguisticType: Linguistic type non existent!')
		return None
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.getParameterDictForTier">
        <p>def <span class="ident">getParameterDictForTier</span>(</p><p>self, idTier)</p>
      </div>
      

      
  
      <div class="desc"><p>Returns a dictionary with all the parameters of the given tier, None if tier doesn't exist</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.getParameterDictForTier', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.getParameterDictForTier" class="source">
      <pre><code>def getParameterDictForTier(self, idTier):
	"""Returns a dictionary with all the parameters of the given tier, None if tier doesn't exist"""
	try:
		return self.tiers[idTier][2]
	except KeyError:
		warnings.warn('getParameterDictForTier: Tier non existent!')
		return None
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.getParticipantForTier">
        <p>def <span class="ident">getParticipantForTier</span>(</p><p>self, idTier)</p>
      </div>
      

      
  
      <div class="desc"><p>Returns the participant for the given tier, '' if none and None if tier doesn't exist</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.getParticipantForTier', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.getParticipantForTier" class="source">
      <pre><code>def getParticipantForTier(self, idTier):
	"""Returns the participant for the given tier, '' if none and None if tier doesn't exist"""
	try:
		tier = self.tiers[idTier]
		return '' if 'PARTICIPANT' not in tier[2] else tier[2]['PARTICIPANT']
	except KeyError:
		warnings.warn('getParticipantForTier: Tier non existent')
		return None
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.getRefAnnotationDataForTier">
        <p>def <span class="ident">getRefAnnotationDataForTier</span>(</p><p>self, idTier)</p>
      </div>
      

      
  
      <div class="desc"><p>Returns all the ref annotation for a given tier in the form: (id-&gt;(ref, value, prev, svg_ref), None if the tier doesn't exist</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.getRefAnnotationDataForTier', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.getRefAnnotationDataForTier" class="source">
      <pre><code>def getRefAnnotationDataForTier(self, idTier):
	"""Returns all the ref annotation for a given tier in the form: (id->(ref, value, prev, svg_ref), None if the tier doesn't exist"""
	try:
		return self.tiers[idTier][1]
	except KeyError:
		warnings.warn('getRefAnnotationDataForTier: Tier non existent!')
		return None
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.getTierIdsForLinguisticType">
        <p>def <span class="ident">getTierIdsForLinguisticType</span>(</p><p>self, lingType, parent=None)</p>
      </div>
      

      
  
      <div class="desc"><p>Returns all the tier id's with the given linguistic type</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.getTierIdsForLinguisticType', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.getTierIdsForLinguisticType" class="source">
      <pre><code>def getTierIdsForLinguisticType(self, lingType, parent=None):
	"""Returns all the tier id's with the given linguistic type"""
	return [t for t in self.tiers if self.tiers[t][2]['LINGUISTIC_TYPE_REF']==lingType and (parent is None or self.tiers[t][2]['PARENT_REF']==parent)]
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.getTierNames">
        <p>def <span class="ident">getTierNames</span>(</p><p>self)</p>
      </div>
      

      
  
      <div class="desc"><p>Returns a list of tiernames</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.getTierNames', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.getTierNames" class="source">
      <pre><code>def getTierNames(self):
	"""Returns a list of tiernames"""
	return self.tiers.keys()
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.getTimeSeries">
        <p>def <span class="ident">getTimeSeries</span>(</p><p>self)</p>
      </div>
      

      
  
      <div class="desc"><p>Gives a list of all time secondary linked txt files</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.getTimeSeries', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.getTimeSeries" class="source">
      <pre><code>def getTimeSeries(self):
	"""Gives a list of all time secondary linked txt files"""
	return [m for m in self.linked_file_descriptors if 'text/plain' in m['MIME_TYPE']]
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.glueAnnotationsInTier">
        <p>def <span class="ident">glueAnnotationsInTier</span>(</p><p>self, tier, tierName=None, treshhold=85, filtin=None, filtex=None)</p>
      </div>
      

      
  
      <div class="desc"><p>Glues all the continues annotations together, returns 0 if succesfull</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.glueAnnotationsInTier', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.glueAnnotationsInTier" class="source">
      <pre><code>def glueAnnotationsInTier(self, tier, tierName=None, treshhold=85, filtin=None, filtex=None):
	"""Glues all the continues annotations together, returns 0 if succesfull"""
	if tier not in self.tiers:
		warnings.warn('glueAnnotationsInTier: Tier non existent!')
		return 1
	if tierName is None: 
		tierName = '%s_glued' % tier
	self.removeTier(tierName)
	self.addTier(tierName)
	tierData = sorted(self.getAnnotationDataForTier(tier), key=lambda a: a[0])
	tierData = [t for t in tierData if (filtin is None or t[2] in filtin) and (filtex is None or t[2] not in filtex)]
	currentAnn = None
	for i in xrange(0, len(tierData)):
		if currentAnn is None:
			currentAnn = (tierData[i][0], tierData[i][1], tierData[i][2])
		elif tierData[i][0]-currentAnn[1]<treshhold:
			currentAnn = (currentAnn[0], tierData[i][1], '%s_%s' % (currentAnn[2], tierData[i][2]))
		else:
			self.insertAnnotation(tierName, currentAnn[0], currentAnn[1], currentAnn[2])
			currentAnn = tierData[i]
	if currentAnn is not None:
		self.insertAnnotation(tierName, currentAnn[0], tierData[len(tierData)-1][1], currentAnn[2])
	return 0
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.hasLinguisticType">
        <p>def <span class="ident">hasLinguisticType</span>(</p><p>self, lingtype)</p>
      </div>
      

      
  
      <div class="desc"><p>Returns if the given type is in the linguistic types</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.hasLinguisticType', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.hasLinguisticType" class="source">
      <pre><code>def hasLinguisticType(self, lingtype):
	"""Returns if the given type is in the linguistic types"""
	return lingtype in self.linguistic_types
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.insertAnnotation">
        <p>def <span class="ident">insertAnnotation</span>(</p><p>self, idTier, start, end, value='', svg_ref=None)</p>
      </div>
      

      
  
      <div class="desc"><p>Add an annotation in the given tier, returns 0 if succesfull</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.insertAnnotation', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.insertAnnotation" class="source">
      <pre><code>def insertAnnotation(self, idTier, start, end, value='', svg_ref=None):
	"""Add an annotation in the given tier, returns 0 if succesfull"""
	try:
		startTs = self.generateTsId(start)
		endTs = self.generateTsId(end)
		self.tiers[idTier][0][self.generateAnnotationId()] = (startTs, endTs, value, svg_ref)
		return 0
	except KeyError:
		warnings.warn('insertAnnotation: Tier non existent')
		return 1
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.insertRefAnnotation">
        <p>def <span class="ident">insertRefAnnotation</span>(</p><p>self, idTier, ref, value, prev, svg_ref=None)</p>
      </div>
      

      
  
      <div class="desc"><p>Adds a reference annotation to the given tier, 0 if succesfull</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.insertRefAnnotation', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.insertRefAnnotation" class="source">
      <pre><code>def insertRefAnnotation(self, idTier, ref, value, prev, svg_ref=None):
	"""Adds a reference annotation to the given tier, 0 if succesfull"""
	try:
		self.tiers[idTier][1][self.generateAnnotationId()] = (ref, value, prev, svg_ref)
		return 0
	except KeyError:
		warnings.warn('insertRefAnnotation: Tier non existent')
		return 1
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.mergeTiers">
        <p>def <span class="ident">mergeTiers</span>(</p><p>self, tiers, tiernew=None, gaptresh=1)</p>
      </div>
      

      
  
      <div class="desc"><p>Merges the given tiers together in the new tier, returns 0 if succesfull</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.mergeTiers', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.mergeTiers" class="source">
      <pre><code>def mergeTiers(self, tiers, tiernew=None, gaptresh=1):
	"""Merges the given tiers together in the new tier, returns 0 if succesfull"""
	if len([t for t in tiers if t not in self.tiers]) > 0:
		warnings.warn('mergeTiers: One or more tiers non existent!')
		return 1        
	if tiernew is None: 
		tiernew = '%s_Merged' % '_'.join(tiers)
	self.removeTier(tiernew)
	self.addTier(tiernew)
	try:
		timepts = sorted(set.union(\
		*[set(j for j in xrange(d[0], d[1])) for d in\
		[ann for tier in tiers for ann in self.getAnnotationDataForTier(tier)]]))
	except TypeError:
		warnings.warn('mergeTiers: No annotations found!')
		return 1
	if len(timepts) > 1:
		start = timepts[0]
		for i in xrange(1, len(timepts)):
			if timepts[i]-timepts[i-1] > gaptresh:
				self.insertAnnotation(tiernew, start, timepts[i-1], self.generateAnnotationConcat(tiers, start, timepts[i-1]))
				start = timepts[i]
		self.insertAnnotation(tiernew, start, timepts[i-1], self.generateAnnotationConcat(tiers, start, timepts[i-1]))
	return 0
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.removeAllAnnotationsFromTier">
        <p>def <span class="ident">removeAllAnnotationsFromTier</span>(</p><p>self, idTier)</p>
      </div>
      

      
  
      <div class="desc"><p>Removes all the annotations from the given tier, returns 0 if succesfull</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.removeAllAnnotationsFromTier', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.removeAllAnnotationsFromTier" class="source">
      <pre><code>def removeAllAnnotationsFromTier(self, idTier):
	"""Removes all the annotations from the given tier, returns 0 if succesfull"""
	try:
		self.tiers[idTier][0], self.tiers[idTier][1] = {}, {}
		self.cleanTimeSlots()
		return 0
	except KeyError: 
		warnings.warn('removeAllAnnotationsFromTier: Tier non existent!')
		return 1
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.removeAnnotation">
        <p>def <span class="ident">removeAnnotation</span>(</p><p>self, time, tier, clean=True)</p>
      </div>
      

      
  
      <div class="desc"><p>Removes an annotation at the given time point in the given tier, returns 0 if succesfull</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.removeAnnotation', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.removeAnnotation" class="source">
      <pre><code>def removeAnnotation(self, time, tier, clean=True):
	"""Removes an annotation at the given time point in the given tier, returns 0 if succesfull"""
	try:
		for b in [a for a in self.tiers[tier][0].iteritems() if a[1][0]>=time and a[1][1]<=time]:
			del(self.tiers[tier][0][b[0]])
			return 0
	except KeyError:
		warnings.warn('removeAnnotation: Tier non existent')
	return 1
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.removeControlledVocabulary">
        <p>def <span class="ident">removeControlledVocabulary</span>(</p><p>self, cv)</p>
      </div>
      

      
  
      <div class="desc"><p>Removes a controlled vocabulary, returns 0 if succesfull</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.removeControlledVocabulary', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.removeControlledVocabulary" class="source">
      <pre><code>def removeControlledVocabulary(self, cv):
	"""Removes a controlled vocabulary, returns 0 if succesfull"""
	try:
		del(self.controlled_vocabularies[cv])
		return 0
	except KeyError:
		warnings.warn('removeControlledVocabulary: Controlled vocabulary non existent!')
		return 1
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.removeLinguisticType">
        <p>def <span class="ident">removeLinguisticType</span>(</p><p>self, lingType)</p>
      </div>
      

      
  
      <div class="desc"><p>Removes a linguistic type, returns 0 if succesfull</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.removeLinguisticType', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.removeLinguisticType" class="source">
      <pre><code>def removeLinguisticType(self, lingType):
	"""Removes a linguistic type, returns 0 if succesfull"""
	try:
		del(self.linguistic_types[lingType])
		return 0
	except KeyError:
		warnings.warn('removeLinguisticType: Linguistic type non existent!')
		return 1
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.removeTier">
        <p>def <span class="ident">removeTier</span>(</p><p>self, idTier, check=False, clean=True)</p>
      </div>
      

      
  
      <div class="desc"><p>Removes a tier by id, returns 0 if succesfull</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.removeTier', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.removeTier" class="source">
      <pre><code>def removeTier(self, idTier, check=False, clean=True):
	"""Removes a tier by id, returns 0 if succesfull"""
	try:
		del(self.tiers[idTier])
		if clean: 
			self.cleanTimeSlots()
		return 0
	except KeyError:	
		if check: warnings.warn('removeTier: Tier non existent!\n' + 'looking for: ' + idTier)
		return 1
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.removeTiers">
        <p>def <span class="ident">removeTiers</span>(</p><p>self, tiers)</p>
      </div>
      

      
  
      <div class="desc"><p>Removes the given tiers</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.removeTiers', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.removeTiers" class="source">
      <pre><code>def removeTiers(self, tiers):
	"""Removes the given tiers"""
	for a in tiers:
		self.removeTier(a, check=False, clean=False)
	self.cleanTimeSlots()
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.shiftAnnotations">
        <p>def <span class="ident">shiftAnnotations</span>(</p><p>self, time)</p>
      </div>
      

      
  
      <div class="desc"><p>Returns a copy of the object with the timeshift of the desired ms (negative for right shift, positive for left shift)</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.shiftAnnotations', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.shiftAnnotations" class="source">
      <pre><code>def shiftAnnotations(self, time):
	"""Returns a copy of the object with the timeshift of the desired ms (negative for right shift, positive for left shift)"""
	e = self.extract(-1*time, self.getFullTimeInterval()[1]) if time < 0 else self.extract(0, self.getFullTimeInterval()[1]-time)
	for tier in e.tiers.itervalues():
		for ann in tier[0].itervalues():
			e.timeslots[ann[0]],e.timeslots[ann[1]] = e.timeslots[ann[0]]+offset, e.timeslots[ann[1]]+offset
	e.cleanTimeSlots()
	return e
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.toTextGrid">
        <p>def <span class="ident">toTextGrid</span>(</p><p>self, filePath, excludedTiers=[])</p>
      </div>
      

      
  
      <div class="desc"><p>Converts the object to praat's TextGrid format and leaves the excludedTiers(optional) behind. returns 0 when succesfull</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.toTextGrid', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.toTextGrid" class="source">
      <pre><code>def toTextGrid(self, filePath, excludedTiers=[]):
	"""Converts the object to praat's TextGrid format and leaves the excludedTiers(optional) behind. returns 0 when succesfull"""
	try:
		from pympi.Praat import TextGrid
	except ImportError:
		warnings.warn('Please install the pympi.Praat module from the pympi module found at https://github.com/dopefishh/pympi')
		return 1
	tgout = TextGrid()
	for tier in [a for a in self.tiers if a not in excludedTiers]:
		currentTier = tgout.addTier(tier)
		for interval in self.getAnnotationDataForTier(tier):
			currentTier.addInterval(interval[0]/1000.0, interval[1]/1000.0, interval[2])
	tgout.tofile(filePath)
	return 0
</code></pre>
    </div>
</div>

    </div>
  
                  
    <div class="item">
      <div class="name def" id="pympi.Elan.Eaf.tofile">
        <p>def <span class="ident">tofile</span>(</p><p>self, filePath, pretty=True)</p>
      </div>
      

      
  
      <div class="desc"><p>Exports the eaf object to a file given by the path, if pretty is false no indentation is used</p></div>
    <div class="source_cont">
    <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pympi.Elan.Eaf.tofile', this);">Show source.</a></p>
    <div id="source-pympi.Elan.Eaf.tofile" class="source">
      <pre><code>def tofile(self, filePath, pretty=True):
	"""Exports the eaf object to a file given by the path, if pretty is false no indentation is used"""
	EafIO.toEaf(filePath, self)
</code></pre>
    </div>
</div>

    </div>
  
        </div>
      </div>



<hr>
<p style="text-align: right;">
  Documentation generated by
  <code><a href="https://github.com/BurntSushi/pdoc">pdoc</a></code>
  0.1.8.

  pdoc is in the public domain with the
  <a href="http://unlicense.org">UNLICENSE</a>.
</p>
</div>
</body>
</html>
